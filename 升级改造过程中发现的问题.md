TypeScript到JavaScript的转换，很多方法不太兼容，具有代表性的就是Promise.resolve();

有的函数明明没有参数，却给了参数，没有给参数，却需要参数，点进去一看，参数已经不用了。

断言的重要性，现有断言帮助我认识代码，我加断言，后面第一时间出问题

for await of的使用,与由于TypeScript和JavaScript语法检查，环境变化导致。

```text
这个问题的根源在于 JavaScript 的动态类型检查 和 TypeScript 的静态类型检查 之间的区别。

1. JavaScript 运行时的行为：
在 JavaScript 中，for await...of 可以用于任何实现了异步迭代器协议的对象。而 ReadableStream 在某些上下文中（比如 Node.js 的 Readable）是可以被异步迭代的。这使得代码在运行时不会抛出错误。

2. TypeScript 静态类型检查的行为：
TypeScript 是静态类型语言，它会在编译时检查 readable 是否符合异步迭代器的要求。

在浏览器环境中的 ReadableStream
在浏览器中，ReadableStream 并不是原生异步可迭代对象，它没有实现异步迭代器协议（Symbol.asyncIterator）。所以 TypeScript 会报错：

在 Node.js 环境中的 Readable
Node.js 的 Readable 流实现了异步迭代器协议，可以直接用于 for await...of。如果你在 Node.js 环境使用的是 Readable，TypeScript 通常不会报错。
```

switch对象还可以是一个参数：getStyleToAppend

引入外部的JavaScript：OPENJPEG