TypeScript到JavaScript的转换，很多方法不太兼容，具有代表性的就是Promise.resolve();

有的函数明明没有参数，却给了参数，没有给参数，却需要参数，点进去一看，参数已经不用了。

断言的重要性，现有断言帮助我认识代码，我加断言，后面第一时间出问题

for await of的使用,与由于TypeScript和JavaScript语法检查，环境变化导致。

```text
这个问题的根源在于 JavaScript 的动态类型检查 和 TypeScript 的静态类型检查 之间的区别。

1. JavaScript 运行时的行为：
在 JavaScript 中，for await...of 可以用于任何实现了异步迭代器协议的对象。而 ReadableStream 在某些上下文中（比如 Node.js 的 Readable）是可以被异步迭代的。这使得代码在运行时不会抛出错误。

2. TypeScript 静态类型检查的行为：
TypeScript 是静态类型语言，它会在编译时检查 readable 是否符合异步迭代器的要求。

在浏览器环境中的 ReadableStream
在浏览器中，ReadableStream 并不是原生异步可迭代对象，它没有实现异步迭代器协议（Symbol.asyncIterator）。所以 TypeScript 会报错：

在 Node.js 环境中的 Readable
Node.js 的 Readable 流实现了异步迭代器协议，可以直接用于 for await...of。如果你在 Node.js 环境使用的是 Readable，TypeScript 通常不会报错。
```

switch对象还可以是一个参数：getStyleToAppend

引入外部的JavaScript：OPENJPEG

变量的重复使用，在JavaScript中和TypeScript中不兼容。

数组的声明也比较麻烦，不能直接声明

有趣的吐槽，别的PDF生成器生成的错误文件，PDF作者也要把它纠正了

代码之间的循环依赖，display层和webviewer层之间的互相调用

诡异的事，undefined && boolean的结果居然是undefined

没有接口导致的类与类之间的不兼容，比如Font和TranslateFont

父类子类的顺序颠倒，父类直接调用子类的方法和函数，父类没有这些属性和函数

元祖比数组更加精确，且使用面也比较广，在Java中我也用到过这个，但是不是Java内置的，好奇为什么Java不增加元组类型？

奇怪的报错：
#zIndex = AnnotationEditor._zIndex++;
局部属性必须在静态属性下面声明，比如就会报没有初始化的错

还是要多思考一下面向对象，接口、继承、多态这些事。尤其是怎么规范好现有的类和接口

为什么我在TypeScript的接口中已经定义了一个方法，当我使用一个抽象类去实现它的时候，仍然要去再次声明它为抽象方法？
